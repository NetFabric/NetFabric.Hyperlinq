# NetFabric.Hyperlinq.Abstractions

This library provides abstractions for optimizing the performance of enumerations.

## IValueEnumerable Interface

In this package, you'll find the `IValueEnumerable<out T, out TEnumerator>` interface. It's designed for collections that want a value type enumerator for better performance, avoiding the enumerator boxing present in `IEnumerable` and `IEnumerable<T>`.

## Value Delegates

In C#, the commonly used predefined delegates [Func<T>](https://github.com/dotnet/dotnet/blob/57e423d62059914d1b92854b656abecdc120e538/src/runtime/src/libraries/System.Private.CoreLib/src/System/Function.cs#L6) and [Action<T>](https://github.com/dotnet/dotnet/blob/57e423d62059914d1b92854b656abecdc120e538/src/runtime/src/libraries/System.Private.CoreLib/src/System/Action.cs#L9) can lead to performance issues due to heap allocation and virtual calls. Value delegates address this by providing optimized performance for resource-intensive scenarios.

It's worth noting that value delegates aren't automatically supported by the compiler and need explicit implementation.

The package introduces interfaces like `IAction<T>`, `IFunction<T, TResult>`, `IAsyncFunction<T, TResult>`, and `IVectorAction<T>`. These interfaces define a method `Invoke()` that can be implemented by a value type. Instances of this value type can replace traditional delegates as parameters and can also hold state, similar to the reference type generated by the compiler when using delegates.

Here's an example of a value type, `SumValueAction<T>`, implementing `IAction<T>` for calculating the sum:

```csharp
public struct SumValueAction<T> : IAction<T>
    where T : struct, IAdditiveIdentity<T, T>, IAdditionOperators<T, T, T>
{
    T sum;

    public SumValueAction()
    {
        sum = T.AdditiveIdentity;
    }

    public readonly T Result
        => sum;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void IAction<T>.Invoke(ref readonly T item) 
        => sum += item;
}
```

Here's an example of a method implementation that's support the use of a value delegate:

```csharp
public static void ForEachEx<T, TAction>(this IEnumerable<T> source, ref TAction action)
    where TAction : struct, IAction<T>
{
    foreach (var item in source)
        action.Invoke(in item);
}
```

The use of the interface as a constraint avoids the boxing of the value delegate.

These can be used as follow to calculate the sum of the elements of a collection:

```csharp
var action = new SumValueAction<int>();
collection.ForEachEx(ref action);
console.WriteLine(action.Result);
```

The package also includes wrappers enabling the use of delegates, along with implicit cast operators converting a delegate to a value delegate.

References:

- ["An interface for value-type enumerators, a proposal"](https://www.linkedin.com/pulse/interface-value-type-enumerators-proposal-ant%25C3%25A3o-almada/)
- ["The Battle of Loops: foreach vs. ForEach in C#"](https://www.linkedin.com/pulse/battle-loops-foreach-vs-c-ant%25C3%25A3o-almada/)